<!DOCTYPE html>
<html><head>
	<meta charset="UTF-8" >
	<link rel="StyleSheet" href="./Visualization.css" type="text/css" >
	<title> Hierarchical Performance Results Visualization </title>
</head>
<body onload="window.resizeTo(1600, 1400)" >

<!-- 제목 -->
<div class="graph_label" id="title" >
	<h2 style="" >
		계층적 성능 분석 결과 
	</h2>
</div>

<!-- label, # of recored to be analyzed -->
<div class="dc-data-count" style="float:left; " >
	선택된 데이터 <span class="filter-count" > </span> 개 / 전체 데이터 <span class="total-count" > </span> 개 <a href="javascript:dc.filterAll(); dc.renderAll();" > 전체 필터 및 그룹핑 초기화 </a> 
</div>

<!-- 맨위 3개 그래프, 시스템콜 레벨-->
<div class="row" style="clear:both; " >
	<div id="io-timeline-chart1" class="dc-chart" >
		<h2>
			시스템콜레벨 평균응답시간
		</h2>
		(x축: 시간축, y축: 평균응답시간(s))
		<a class="reset" href="javascript:Timeline_IOCount_Chart1.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-volume-chart1" >
		<h2>
			시스템콜레벨 처리량 
		</h2>
		(x축: 시간축, y축: 처리량(MB/s))
		<a class="reset" href="javascript:Timeline_IOCount_Chart1.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-count-chart1" >
		<h2>
			시스템콜레벨 I/O요청회수 
		</h2>
		(x축: 시간축, y축: 요청 개수)
		<a class="reset" href="javascript:Timeline_IOCount_Chart1.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div class="row" >
		<h3>
			<div id="nr_dataset1"> 수집된 데이터: <span class="number-display">_</span> 개</div>
		</h3><br>
		<h3>
			<div id="AvgThroughtput1">평균처리량: <span class="number-display">_</span> MB/s </div>
		</h3><br>
		<h3>
			<div id="AvgRTtime1">평균응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="TotalIOSize1">총IO크기: <span class="number-display">_</span> MB </div>
		</h3><br>
		<h3>
			<div id="TotalRTtime1">총IO응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="Variance1">분산(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
		<h3>
			<div id="StdDeviation1">표준편차(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
	</div>
	<div id="clearfix" ></div>
</div>

<!-- 가운데 3개 그래프, 블록 레벨 -->
<div class="row" style="clear:both; " >
	<div id="io-timeline-chart2" class="dc-chart" >
		<h2>
			블록레벨 평균응답시간 
		</h2>
		(x축: 시간축, y축: 평균응답시간(s))
		 <a class="reset" href="javascript:Timeline_IOCount_Chart2.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-volume-chart2" >
		<h2>
			블록레벨 처리량 
		</h2>
		(x축: 시간축, y축: 처리량(MB/s))
		<a class="reset" href="javascript:Timeline_IOCount_Chart2.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-count-chart2" >
		<h2>
			블록레벨 I/O요청회수
		</h2>
		(x축: 시간축, y축: 요청 개수)
		<a class="reset" href="javascript:Timeline_IOCount_Chart2.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div class="row" >
		<h3>
			<div id="nr_dataset2"> 수집된 데이터: <span class="number-display">_</span> 개</div>
		</h3><br>
		<h3>
			<div id="AvgThroughtput2">평균처리량: <span class="number-display">_</span> MB/s </div>
		</h3><br>
		<h3>
			<div id="AvgRTtime2">평균응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="TotalIOSize2">총IO크기: <span class="number-display">_</span> MB </div>
		</h3><br>
		<h3>
			<div id="TotalRTtime2">총IO응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="Variance2">분산(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
		<h3>
			<div id="StdDeviation2">표준편차(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
	</div>
	<div id="clearfix" ></div>
</div>

<!-- 밑 3개 그래프, eMMC 레벨 -->
<div class="row" style="clear:both; " >
	<div id="io-timeline-chart3" class="dc-chart" >
		<h2>
			eMMC레벨 평균응답시간 
		</h2>
		(x축: 시간축, y축: 평균응답시간(s))
		 <a class="reset" href="javascript:Timeline_IOCount_Chart3.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-volume-chart3" >
		<h2>
			eMMC레벨 처리량 
		</h2>
		(x축: 시간축, y축: 처리량(MB/s))
		<a class="reset" href="javascript:Timeline_IOCount_Chart3.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-count-chart3" >
		<h2>
			eMMC레벨 I/O요청회수
		</h2>
		(x축: 시간축, y축: 요청 개수)
		<a class="reset" href="javascript:Timeline_IOCount_Chart3.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div class="row" >
		<h3>
			<div id="nr_dataset3"> 수집된 데이터: <span class="number-display">_</span> 개</div>
		</h3><br>
		<h3>
			<div id="AvgThroughtput3">평균처리량: <span class="number-display">_</span> MB/s </div>
		</h3><br>
		<h3>
			<div id="AvgRTtime3">평균응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="TotalIOSize3">총IO크기: <span class="number-display">_</span> MB </div>
		</h3><br>
		<h3>
			<div id="TotalRTtime3">총IO응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="Variance3">분산(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
		<h3>
			<div id="StdDeviation3">표준편차(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
	</div>
	<div id="clearfix" ></div>
</div>

<!-- 최종 3개 그래프, I/O 처리 시간 그래프, 시스템콜 레벨부터, eMMC 레벨까지 연결 -->
<div class="row" style="clear:both; " >
	<div id="io-timeline-chart4" class="dc-chart" >
		<h2>
			I/O처리 평균응답시간 
		</h2>
		(x축: 시간축, y축: 평균응답시간(s))
		 <a class="reset" href="javascript:Timeline_IOCount_Chart4.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	<div id="io-volume-chart4" >
		<h2>
			I/O 처리량 
		</h2>
		(x축: 시간축, y축: 처리량(MB/s))
		<a class="reset" href="javascript:Timeline_IOCount_Chart4.filterAll();dc.redrawAll();" style="display:none; " > reset  </a> <div id="clearfix" ></div>
	</div>
	
	<div class="row" >
		<h3>
			<div id="nr_dataset4"> 수집된 데이터: <span class="number-display">_</span> 개</div>
		</h3><br>
		<h3>
			<div id="AvgThroughtput4">평균처리량: <span class="number-display">_</span> MB/s </div>
		</h3><br>
		<h3>
			<div id="AvgRTtime4">평균응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="TotalIOSize4">총IO크기: <span class="number-display">_</span> MB </div>
		</h3><br>
		<h3>
			<div id="TotalRTtime4">총IO응답시간: <span class="number-display">_</span> s </div>
		</h3><br>
		<h3>
			<div id="Variance4">분산(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
		<h3>
			<div id="StdDeviation4">표준편차(응답시간): <span class="number-display">_</span> </div>
		</h3><br>
	</div>
	<div id="clearfix" ></div>
</div>

<!-- 필터들 -->

 <div class="row" >
	<div id="process_bubble_chart" class="dc-chart" >
		<h2>
			<strong> PID별 I/O 특성 <br>
			(x축: I/O 요청 개수, y축: I/O별 평균 응답 시간)</strong> 
		</h2>
		 <a class="reset" href="javascript:PID_BubbleChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
	</div>
	<div id="rt_distribution_chart" class="dc-chart" >
		<h2>
			<strong> 응답 시간 분포 그래프 <br>
			(x축: 응답시간, y축: 개수) </strong> 
		</h2>
		 <a class="reset" href="javascript:RT_Distribution_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
	</div>
	<div id="process_chart" class="dc-chart" >
		<h2>
			<strong> 프로세스 이름별 I/O 요청 비율 </strong> 
		</h2>
		(면적: I/O 요청 비율) <a class="reset" href="javascript:ProcessName_IORatio_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
		<div class="clearfix" >
		</div>
	</div>
	<div id="type_chart" class="dc-chart" >
		<h2>
			<strong> 읽기 / 쓰기 비율 </strong> 
		</h2>
		(면적: I/O 요청 비율) <a class="reset" href="javascript:IOType_IORatio_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
		<div class="clearfix" >
		</div>
	</div>
</div>


<div class="row" >
	<div id="process_throughput_chart" >
		<h2>
			<strong> 프로세스별 평균 처리량 <br>
			(x축: 처리량, y축: 프로세스 이름) </strong>
		</h2>
		<a class="reset" href="javascript:Process_Throughput_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
	</div>
	<div id="pid_throughput_chart" >
		<h2>
			<strong> PID별 평균 처리량 <br>
			(x축: 처리량, y축: PID)</strong>
		</h2>
		 <a class="reset" href="javascript:PID_Throughput_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
	</div>
	<div id="file_count_chart" class="dc-chart" >
		<h2>
			<strong> 접근 파일별 I/O 요청 개수 <br>
			(x축: I/O 요청 개수, y축: 접근 파일)</strong> 
		</h2>
		 <a class="reset" href="javascript:File_AccessCount_Chart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> <div id="clearfix" ></div>
	</div>

</div>

<!-- anchor div for data table -->
<!--
<div class="row">
	<div id="data-table">
	        <span>Avg.Throughput</span>
	        <span>Avg.ResponseTime</span>
	        <span>Total.IO size</span>
	        <span>total.IOTime</span>
	</div>
</div>
-->

<!--
	<div id="file_rt_chart">
		<h2>
			<strong> 접근 파일별 평균 응답 시간</strong> 
		</h2>
		(x축: 평균 응답 시간, y축: 접근 파일) <a class="reset" href="javascript:FileRTChart.filterAll();dc.redrawAll();" style="display: none;"> 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix">
		</div>
	</div>
-->
<!--
</div>
<div id="io_category_aver_4layer_response_time_chart" style="clear:left">
	<h2>
		<strong> Average eMMC, Block, Cache, FS Layer Response Time per each IO category</strong> ㄴㅊ
	</h2>
	(x: Aver. Response Time, y: categories (eMMC-blue, BLOCK-red, CACHE-green, FS-blue )) <a class="reset" href="javascript:IOCategoryAver4LayerRTChart.filterAll();dc.redrawAll();" style="display: none;"> 해당 필터 및 그룹핑 초기화  </a> 
</div>
-->


<script type="text/javascript" src="/Users/elsdy/Dropbox/Development/HFIOSA/VisualizationDevelopment/js/d3/d3.js" > </script>
<script type="text/javascript" src="/Users/elsdy/Dropbox/Development/HFIOSA/VisualizationDevelopment/js/crossfilter/crossfilter.js" > </script>
<script type="text/javascript" src="/Users/elsdy/Dropbox/Development/HFIOSA/VisualizationDevelopment/js/dc/dc.js" > </script>
<script type="text/javascript">

document.body.style.zoom=0.88;

/* var IOCategoryAver4LayerRTChart = dc.barChart("#io_category_aver_4layer_response_time_chart"); */

/* var FileRTChart = dc.barChart("#file_rt_chart"); */

/* var TimeLine_SysLevelAvgRT_Chart = dc.compositeChart("#io-timeline-chart1"); */

var Timeline_RT_Chart1 = dc.barChart("#io-timeline-chart1");
var Timeline_Throughput_Chart1 = dc.barChart("#io-volume-chart1");
var Timeline_IOCount_Chart1 = dc.barChart("#io-count-chart1");

var NR_Dataset1ND = dc.numberDisplay("#nr_dataset1");
var AvgThroughtputND1   = dc.numberDisplay("#AvgThroughtput1");
var AvgRTtimeND1   = dc.numberDisplay("#AvgRTtime1");
var TotalIOSizeND1   = dc.numberDisplay("#TotalIOSize1");
var TotalRTtimeND1   = dc.numberDisplay("#TotalRTtime1");
var VarianceND1   = dc.numberDisplay("#Variance1");
var StdDeviationND1   = dc.numberDisplay("#StdDeviation1");

var Timeline_RT_Chart2 = dc.barChart("#io-timeline-chart2");
var Timeline_Throughput_Chart2 = dc.barChart("#io-volume-chart2");
var Timeline_IOCount_Chart2 = dc.barChart("#io-count-chart2");

var NR_Dataset2ND = dc.numberDisplay("#nr_dataset2");
var AvgThroughtputND2   = dc.numberDisplay("#AvgThroughtput2");
var AvgRTtimeND2   = dc.numberDisplay("#AvgRTtime2");
var TotalIOSizeND2   = dc.numberDisplay("#TotalIOSize2");
var TotalRTtimeND2   = dc.numberDisplay("#TotalRTtime2");
var VarianceND2   = dc.numberDisplay("#Variance2");
var StdDeviationND2   = dc.numberDisplay("#StdDeviation2");

var Timeline_RT_Chart3 = dc.barChart("#io-timeline-chart3");
var Timeline_Throughput_Chart3 = dc.barChart("#io-volume-chart3");
var Timeline_IOCount_Chart3 = dc.barChart("#io-count-chart3");

var NR_Dataset3ND = dc.numberDisplay("#nr_dataset3");
var AvgThroughtputND3   = dc.numberDisplay("#AvgThroughtput3");
var AvgRTtimeND3   = dc.numberDisplay("#AvgRTtime3");
var TotalIOSizeND3   = dc.numberDisplay("#TotalIOSize3");
var TotalRTtimeND3   = dc.numberDisplay("#TotalRTtime3");
var VarianceND3   = dc.numberDisplay("#Variance3");
var StdDeviationND3   = dc.numberDisplay("#StdDeviation3");

var Timeline_RT_Chart4 = dc.barChart("#io-timeline-chart4");
var Timeline_Throughput_Chart4 = dc.barChart("#io-volume-chart4");

var NR_Dataset4ND = dc.numberDisplay("#nr_dataset4");
var AvgThroughtputND4   = dc.numberDisplay("#AvgThroughtput4");
var AvgRTtimeND4   = dc.numberDisplay("#AvgRTtime4");
var TotalIOSizeND4   = dc.numberDisplay("#TotalIOSize4");
var TotalRTtimeND4   = dc.numberDisplay("#TotalRTtime4");
var VarianceND4   = dc.numberDisplay("#Variance4");
var StdDeviationND4   = dc.numberDisplay("#StdDeviation4");

var PID_BubbleChart = dc.bubbleChart("#process_bubble_chart");
var RT_Distribution_Chart = dc.barChart("#rt_distribution_chart");
var ProcessName_IORatio_Chart = dc.pieChart("#process_chart");
var IOType_IORatio_Chart = dc.pieChart("#type_chart");

var Process_Throughput_Chart = dc.rowChart("#process_throughput_chart");
var PID_Throughput_Chart = dc.rowChart("#pid_throughput_chart");
var File_AccessCount_Chart = dc.rowChart("#file_count_chart");

/* var StatTable = dc.dataTable("#data-table"); */

var Full_Width = 1800;
var Default_Height = 180;
var n_rowchart_ticks = 3;
var n_bubblechart_ticks = 5;

var top1 = 20, bottom1 = 20, left1 = 70, right1 = 10;
var height1 = Default_Height;
var width1 = Full_Width / 4;

var top2 = 20, bottom2 = 20, left2 = 70, right2 = 10;
var height2 = Default_Height;
var width2 = Full_Width / 4;

var iogroup_size = new Array (4,8,16,32,64,128,256,512,1024,2048,4096);

function classifyIoSize(d)
{
	for (var i in iogroup_size) {
		if(d < i)
			return i;
	}
}

d3.csv("final_result.csv", function(error, data) {


	var IOTimeLineChart_x_low = Number.MAX_VALUE; // 입력 파일에서 타임 라인에 나오는 최초 시간값
	var IOTimeLineChart_x_high = 0;					// 입력 파일에서 타임 라인에 나오는 최후 시간값

	var MaxIORT = 0;

	var ProcessBubbleChart_x_low = Number.MAX_VALUE; // bubble chart에서 사용할 최초 시간값
	var ProcessBubbleChart_x_high = 0;					// bubble chart에서 사용할 최후 시간값
	
	var transition_duration_delay = 2500;				// 페이지 로드 완료후, 그래프가 animate 될 때까지 의 지연 시간
	
	var n_timeline_unit = 1500; // 타임 라인 그래프의 구간을 몇으로 할 것인지 결정
	var bargap = n_timeline_unit*1000000;

	// Parse numbers, and sort by value.
	// data.forEach에서 하는 일
	// 입력 파일의 모든 데이터값들을 순서대로 읽어서 무슨 일인가를 한다. 
	// 1. string -> 적절한 데이터 형으로 변환
	// 입력 데이터의 각 필드 값들은 처음에는 무조건 string 타입으로 간주되므로
	// 사용하려는 용도에 따라 정수, 실수 형으로 변환하는 작업이 필요하다.
	// 2. 새로운 필드값 추가
	// 필요에 따라서 입력 데이터값을 cooking 하여 새로운 필드 값을 만들어야 할 필요가 있다. 
	data.forEach(function(d) {
		// all,entry_type,linenumber,processname,origin_processname,pid, start_time,end_time,rw,iosize,filename,inode,mapped_syscall_io
		d.entry_type = +d.entry_type;
		d.linenumber = +d.linenumber;
		// d.processname
		// d.origin_processname
		d.pid = +d.pid;
		d.starttime = +d.starttime;
	  	d.endtime = +d.endtime;
	  	// d.rw  
	  	d.iosize = +d.iosize;
	  	d.iosizegroup = classifyIoSize(d.iosize);
	  	// d.filename
	  	d.inode = +d.inode;
	  	d.mapped_syscall_io = +d.mapped_syscall_io;
	  
	  	d.rttime = d.endtime - d.starttime;
	  	if(MaxIORT < d.rttime) MaxIORT = d.rttime;
	  	
	  	// d.category
	  	if(IOTimeLineChart_x_high < d.starttime) IOTimeLineChart_x_high = d.starttime;
	  	if(IOTimeLineChart_x_low > d.starttime) IOTimeLineChart_x_low = d.starttime;	  	
  	});
  	
  	// 전체 시간 구간을 n_timeline_unit의 개수로 나누어 n_timeline_unit분할 하고
  	// 각 구간의 길이를 계산한다. 
	var div_timeunit = +((IOTimeLineChart_x_high - IOTimeLineChart_x_low)/n_timeline_unit).toFixed(6);
	 
	// 데이터를 다시 읽어서 각 데이터들이 들어갈 시간 그룹을 결정한다. 
	data.forEach(function(d) {
		d.timeline_group = IOTimeLineChart_x_low + Math.floor((d.starttime - IOTimeLineChart_x_low)/ div_timeunit) * div_timeunit;	// 소숫점 이하를 없앤다. 
  	});
  
  	// 그래프를 넉넉히 그리기 위해서 타임 라인을 앞뒤로 3초 연장한다. 
  	IOTimeLineChart_x_low = Math.floor(IOTimeLineChart_x_low)-3;
  	IOTimeLineChart_x_high = Math.ceil(IOTimeLineChart_x_high)+3;
  
  	// crossfilter를 사용하기 위한 데이터 초기화
  	var ndx = crossfilter(data);

  	// 전체를 일단 그룹핑한다. 
  	var all = ndx.groupAll();

// #define SYSCALL_TYPE 1
// #define BLOCK_TYPE 2
// #define EMMC_TYPE 3
// #define PROCESS_TYPE 4

  	// time_group을 dimension으로 설정, reduce 함수를 정의
	var NewStartTimeDimension1 = ndx.dimension(function (d) {
		return d.timeline_group;
	});
	var groupNewStartTimeDimension1 = NewStartTimeDimension1.group().reduce(
		function (p, v) {
			if(v.entry_type == 1)
			{
				++p.count;
						
				if(p.start_time > v.starttime) p.start_time = v.starttime; //이거왜넣었지?
						
			  	p.total_rt += v.endtime - v.starttime;
			  	p.avg_rt = p.total_rt / p.count;

				p.total_iosize += v.iosize;
				p.throughput = (p.total_iosize /  p.total_rt) / (1024*1024)  ; //MB/s

			}
			return p;		  
		},
	  	function (p, v) {
		  	if(v.entry_type == 1)
			{		  		
			  	--p.count;

			  	p.total_rt -= v.endtime - v.starttime;
			  	p.avg_rt = p.count == 0 ? 0: p.total_rt / p.count;

				p.total_iosize -= v.iosize;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_rt) / (1024*1024); //MB/s

			}			
			return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_rt: 0, 
			  	avg_rt: 0,

				total_iosize: 0,			  	
				throughput: 0
		  	};
		}
	);
  
	Timeline_RT_Chart1
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension1)
		.group(groupNewStartTimeDimension1)
		.valueAccessor(function (d) {
				return d.value.avg_rt;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second)
// 		.elasticX(true)
// 		.y(d3.scale.linear().domain([0, 100])) 
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			TimeLine_SysLevelAvgRT_Chart.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				TimeLine_SysLevelAvgRT_Chart.focus(chart.filter());
			});
		})
*/
		;


	Timeline_Throughput_Chart1
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension1)
		.group(groupNewStartTimeDimension1)
		.valueAccessor(function (d) {
				return d.value.throughput;
		})
		.centerBar(true)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) */
// 		.elasticX(true) */
// 		.y(d3.scale.linear().domain([0, 100])) */
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_Throughput_Chart1.focus(chart.filter());
			});
		})
*/
		.gap(bargap)
		;
		
	Timeline_IOCount_Chart1
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension1)
		.group(groupNewStartTimeDimension1)
		.valueAccessor(function (d) {
				return d.value.count;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) 
/* 		.elasticX(true) */
		.y(d3.scale.linear().domain([0, 100]))
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_RT_Chart1.filter(chart.filter());
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_RT_Chart1.focus(chart.filter());
				Timeline_Throughput_Chart1.focus(chart.filter());

				Timeline_RT_Chart2.focus(chart.filter());
				Timeline_Throughput_Chart2.focus(chart.filter());

				Timeline_RT_Chart3.focus(chart.filter());
				Timeline_Throughput_Chart3.focus(chart.filter());
			});
		})
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
		;

	var ALLIODimension1 = ndx.dimension(function (d) {
		return d.all;
		});            

	var groupALLIODimension1 = ALLIODimension1.group().reduce(
		function (p, v) {
			if(v.entry_type == 1)
			{
				++p.count;
				
				if(p.start_time > v.starttime) p.start_time = v.starttime;
				
				
			  	p.total_start_end_interval += v.endtime - v.starttime
				p.total_iosize += v.iosize;
				
			  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}
						  	
		  	return p;		  
		},
	  	function (p, v) {
	  		if(v.entry_type == 1)
	  		{
			  	--p.count;

			  	p.total_start_end_interval -= v.endtime - v.starttime;
				p.total_iosize -= v.iosize;
				
			  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}						
		  	return p;	  	
	  	},
	  	// init
	  	function() { 	  	
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				variance:0,
				std_dev:0
		  	};
		}
	);
	    
    NR_Dataset1ND
    .dimension(ALLIODimension1)
    .group(groupALLIODimension1)
    .valueAccessor(function (p) { 
    	return p.value.count; 
    })
    .formatNumber(d3.format("g"))
    ;
    AvgThroughtputND1
    .dimension(ALLIODimension1)
    .group(groupALLIODimension1)
    .valueAccessor(function (p) { 
    	return p.value.throughput; 
    })
    .formatNumber(d3.format(".8g"))
    ;

	AvgRTtimeND1
	.dimension(ALLIODimension1)
	.group(groupALLIODimension1)
	.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalIOSizeND1
	.dimension(ALLIODimension1)
	.group(groupALLIODimension1)
	.valueAccessor(function (p) {
			return p.value.total_iosize;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalRTtimeND1
	.dimension(ALLIODimension1)
	.group(groupALLIODimension1)
	.valueAccessor(function (p) {
			return p.value.total_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	VarianceND1
	.dimension(ALLIODimension1)
	.group(groupALLIODimension1)
	.valueAccessor(function (p) {
			return p.value.variance;
	})
		    .on("preRender", function(chart){
     //        // 1. calculating the average with the data left after filtering.
     //        // 2. calculating the deviating with the average for each entry in the data set.
     //        // 3. squaring the result from (2) and sum all the entry in the data set.
     //        // 4. dividing the result from (3) with the number of the entries in the data set.
     //        // 5. from (4) I can obtain the variance.
     //        // 6. I want to make the result from (4) label or title of this chart.
	    // 	// console.log(chart.dimension().group().all().forEach(d));

	    	// sigma (pow((avg-e(x)),2)) / count
	    	// squere 
	    	// var Test = chart.dimension().group().top(Infinity);
	    	// Test.forEach(function(d1, a1, b1) {
	    	// 	console.log(d1.value.avg_start_end_interval);
	    	// })
	    	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
		.on("preRedraw", function(chart){
        	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
	.formatNumber(d3.format(".8g"))
	;

	StdDeviationND1
	.dimension(ALLIODimension1)
	.group(groupALLIODimension1)
	.valueAccessor(function (p) {
			return p.value.std_dev;
	})
	.formatNumber(d3.format(".8g"))
	;

  	// time_group을 dimension으로 설정, reduce 함수를 정의
	var NewStartTimeDimension2 = ndx.dimension(function (d) {
		return d.timeline_group;
	});
	var groupNewStartTimeDimension2 = NewStartTimeDimension2.group().reduce(
		function (p, v) {
			if(v.entry_type == 2)
			{
				++p.count;
						
				if(p.start_time > v.starttime) p.start_time = v.starttime; //이거왜넣었지?
						
			  	p.total_rt += v.endtime - v.starttime;
			  	p.avg_rt = p.total_rt / p.count;

				p.total_iosize += v.iosize;
				p.throughput = (p.total_iosize /  p.total_rt) / (1024*1024)  ; //MB/s

			}
			return p;		  
		},
	  	function (p, v) {
		  	if(v.entry_type == 2)
			{		  		
			  	--p.count;

			  	p.total_rt -= v.endtime - v.starttime;
			  	p.avg_rt = p.count == 0 ? 0: p.total_rt / p.count;

				p.total_iosize -= v.iosize;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_rt) / (1024*1024); //MB/s

			}			
			return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_rt: 0, 
			  	avg_rt: 0,

				total_iosize: 0,			  	
				throughput: 0
		  	};
		}
	);

	Timeline_RT_Chart2
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension2)
		.group(groupNewStartTimeDimension2)
		.valueAccessor(function (d) {
				return d.value.avg_rt;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second)
// 		.elasticX(true)
// 		.y(d3.scale.linear().domain([0, 100])) 
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			TimeLine_SysLevelAvgRT_Chart.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				TimeLine_SysLevelAvgRT_Chart.focus(chart.filter());
			});
		})
*/
		;


	Timeline_Throughput_Chart2
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension2)
		.group(groupNewStartTimeDimension2)
		.valueAccessor(function (d) {
				return d.value.throughput;
		})
		.centerBar(true)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) */
// 		.elasticX(true) */
// 		.y(d3.scale.linear().domain([0, 100])) */
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_Throughput_Chart1.focus(chart.filter());
			});
		})
*/
		.gap(bargap)
		;
		
	Timeline_IOCount_Chart2
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension2)
		.group(groupNewStartTimeDimension2)
		.valueAccessor(function (d) {
				return d.value.count;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) 
/* 		.elasticX(true) */
		.y(d3.scale.linear().domain([0, 100]))
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_RT_Chart1.filter(chart.filter());
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_RT_Chart1.focus(chart.filter());
				Timeline_Throughput_Chart1.focus(chart.filter());

				Timeline_RT_Chart2.focus(chart.filter());
				Timeline_Throughput_Chart2.focus(chart.filter());

				Timeline_RT_Chart3.focus(chart.filter());
				Timeline_Throughput_Chart3.focus(chart.filter());
			});
		})
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
		;
		
	var ALLIODimension2 = ndx.dimension(function (d) {
		return d.all;
		});            

	var groupALLIODimension2 = ALLIODimension2.group().reduce(
		function (p, v) {
			if(v.entry_type == 2)
			{
				++p.count;
				
				if(p.start_time > v.starttime) p.start_time = v.starttime;
				
				
			  	p.total_start_end_interval += v.endtime - v.starttime
				p.total_iosize += v.iosize;
				
			  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}		  	
		  	return p;		  
		},
	  	function (p, v) {
	  		if(v.entry_type == 2)
	  		{
			  	--p.count;

			  	p.total_start_end_interval -= v.endtime - v.starttime;
				p.total_iosize -= v.iosize;
				
			  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}							
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				variance:0,
				std_dev:0
		  	};
		}
	);
	    
	NR_Dataset2ND
    .dimension(ALLIODimension2)
    .group(groupALLIODimension2)
    .valueAccessor(function (p) { 
    	return p.value.count; 
    })
    .formatNumber(d3.format("g"))
    ;

    AvgThroughtputND2
    .dimension(ALLIODimension2)
    .group(groupALLIODimension2)
    .valueAccessor(function (p) { 
    	return p.value.throughput; 
    })
    .formatNumber(d3.format(".8g"))
    ;

	AvgRTtimeND2
	.dimension(ALLIODimension2)
	.group(groupALLIODimension2)
	.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalIOSizeND2
	.dimension(ALLIODimension2)
	.group(groupALLIODimension2)
	.valueAccessor(function (p) {
			return p.value.total_iosize;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalRTtimeND2
	.dimension(ALLIODimension2)
	.group(groupALLIODimension2)
	.valueAccessor(function (p) {
			return p.value.total_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	VarianceND2
	.dimension(ALLIODimension2)
	.group(groupALLIODimension2)
	.valueAccessor(function (p) {
			return p.value.variance;
	})
		    .on("preRender", function(chart){
     //        // 1. calculating the average with the data left after filtering.
     //        // 2. calculating the deviating with the average for each entry in the data set.
     //        // 3. squaring the result from (2) and sum all the entry in the data set.
     //        // 4. dividing the result from (3) with the number of the entries in the data set.
     //        // 5. from (4) I can obtain the variance.
     //        // 6. I want to make the result from (4) label or title of this chart.
	    // 	// console.log(chart.dimension().group().all().forEach(d));

	    	// sigma (pow((avg-e(x)),2)) / count
	    	// squere 
	    	// var Test = chart.dimension().group().top(Infinity);
	    	// Test.forEach(function(d1, a1, b1) {
	    	// 	console.log(d1.value.avg_start_end_interval);
	    	// })
	    	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
		.on("preRedraw", function(chart){
        	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
	.formatNumber(d3.format(".8g"))
	;

	StdDeviationND2
	.dimension(ALLIODimension2)
	.group(groupALLIODimension2)
	.valueAccessor(function (p) {
			return p.value.std_dev;
	})
	.formatNumber(d3.format(".8g"))
	;

  	// time_group을 dimension으로 설정, reduce 함수를 정의
	var NewStartTimeDimension3 = ndx.dimension(function (d) {
		return d.timeline_group;
	});
	var groupNewStartTimeDimension3 = NewStartTimeDimension3.group().reduce(
		function (p, v) {
			if(v.entry_type == 3)
			{
				++p.count;
						
				if(p.start_time > v.starttime) p.start_time = v.starttime; //이거왜넣었지?
						
			  	p.total_rt += v.endtime - v.starttime;
			  	p.avg_rt = p.total_rt / p.count;

				p.total_iosize += v.iosize;
				p.throughput = (p.total_iosize /  p.total_rt) / (1024*1024)  ; //MB/s

			}
			return p;		  
		},
	  	function (p, v) {
		  	if(v.entry_type == 3)
			{		  		
			  	--p.count;

			  	p.total_rt -= v.endtime - v.starttime;
			  	p.avg_rt = p.count == 0 ? 0: p.total_rt / p.count;

				p.total_iosize -= v.iosize;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_rt) / (1024*1024); //MB/s

			}			
			return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_rt: 0, 
			  	avg_rt: 0,

				total_iosize: 0,			  	
				throughput: 0
		  	};
		}
	);

// 3번째줄 그래프들
	Timeline_RT_Chart3
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension3)
		.group(groupNewStartTimeDimension3)
		.valueAccessor(function (d) {
				return d.value.avg_rt;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second)
// 		.elasticX(true)
// 		.y(d3.scale.linear().domain([0, 100])) 
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			TimeLine_SysLevelAvgRT_Chart.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				TimeLine_SysLevelAvgRT_Chart.focus(chart.filter());
			});
		})
*/
		;


	Timeline_Throughput_Chart3
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension3)
		.group(groupNewStartTimeDimension3)
		.valueAccessor(function (d) {
				return d.value.throughput;
		})
		.centerBar(true)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) */
// 		.elasticX(true) */
// 		.y(d3.scale.linear().domain([0, 100])) */
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_Throughput_Chart1.focus(chart.filter());
			});
		})
*/
		.gap(bargap)
		;
		
	Timeline_IOCount_Chart3
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension3)
		.group(groupNewStartTimeDimension3)
		.valueAccessor(function (d) {
				return d.value.count;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) 
/* 		.elasticX(true) */
		.y(d3.scale.linear().domain([0, 100]))
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_RT_Chart1.filter(chart.filter());
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_RT_Chart1.focus(chart.filter());
				Timeline_Throughput_Chart1.focus(chart.filter());

				Timeline_RT_Chart2.focus(chart.filter());
				Timeline_Throughput_Chart2.focus(chart.filter());

				Timeline_RT_Chart3.focus(chart.filter());
				Timeline_Throughput_Chart3.focus(chart.filter());
			});
		})
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
		;
		
	var ALLIODimension3 = ndx.dimension(function (d) {
		return d.all;
		});            

	var groupALLIODimension3 = ALLIODimension2.group().reduce(
		function (p, v) {
			if(v.entry_type == 3)
			{
				++p.count;
				
				if(p.start_time > v.starttime) p.start_time = v.starttime;
				
				
			  	p.total_start_end_interval += v.endtime - v.starttime
				p.total_iosize += v.iosize;
				
			  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}		  	
		  	return p;		  
		},
	  	function (p, v) {
	  		if(v.entry_type == 3)
	  		{
			  	--p.count;

			  	p.total_start_end_interval -= v.endtime - v.starttime;
				p.total_iosize -= v.iosize;
				
			  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}						
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				variance:0,
				std_dev:0
		  	};
		}
	);

	NR_Dataset3ND
    .dimension(ALLIODimension3)
    .group(groupALLIODimension3)
    .valueAccessor(function (p) { 
    	return p.value.count; 
    })
    .formatNumber(d3.format("g"))
    ;

	    
    AvgThroughtputND3
    .dimension(ALLIODimension3)
    .group(groupALLIODimension3)
    .valueAccessor(function (p) { 
    	return p.value.throughput; 
    })
    .formatNumber(d3.format(".8g"))
    ;

	AvgRTtimeND3
	.dimension(ALLIODimension3)
	.group(groupALLIODimension3)
	.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalIOSizeND3
	.dimension(ALLIODimension3)
	.group(groupALLIODimension3)
	.valueAccessor(function (p) {
			return p.value.total_iosize;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalRTtimeND3
	.dimension(ALLIODimension3)
	.group(groupALLIODimension3)
	.valueAccessor(function (p) {
			return p.value.total_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	VarianceND3
	.dimension(ALLIODimension3)
	.group(groupALLIODimension3)
	.valueAccessor(function (p) {
			return p.value.variance;
	})
		    .on("preRender", function(chart){
     //        // 1. calculating the average with the data left after filtering.
     //        // 2. calculating the deviating with the average for each entry in the data set.
     //        // 3. squaring the result from (2) and sum all the entry in the data set.
     //        // 4. dividing the result from (3) with the number of the entries in the data set.
     //        // 5. from (4) I can obtain the variance.
     //        // 6. I want to make the result from (4) label or title of this chart.
	    // 	// console.log(chart.dimension().group().all().forEach(d));

	    	// sigma (pow((avg-e(x)),2)) / count
	    	// squere 
	    	// var Test = chart.dimension().group().top(Infinity);
	    	// Test.forEach(function(d1, a1, b1) {
	    	// 	console.log(d1.value.avg_start_end_interval);
	    	// })
	    	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
		.on("preRedraw", function(chart){
        	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
	.formatNumber(d3.format(".8g"))
	;

	StdDeviationND3
	.dimension(ALLIODimension3)
	.group(groupALLIODimension3)
	.valueAccessor(function (p) {
			return p.value.std_dev;
	})
	.formatNumber(d3.format(".8g"))
	;
  	
	// 4번째줄 그래프들
	var NewStartTimeDimension4 = ndx.dimension(function (d) {
		return d.timeline_group;
	});
	var groupNewStartTimeDimension4 = NewStartTimeDimension4.group().reduce(
		function (p, v) {
			if(v.entry_type == 1)
			{
				++p.count;
						
				if(p.start_time > v.starttime) p.start_time = v.starttime; //이거왜넣었지?
						
			  	p.total_rt += v.endtime - v.starttime;
			  	p.avg_rt = p.total_rt / p.count;

				p.total_iosize += v.iosize;
				p.throughput = (p.total_iosize /  p.total_rt) / (1024*1024)  ; //MB/s

			}
			return p;		  
		},
	  	function (p, v) {
		  	if(v.entry_type == 1)
			{		  		
			  	--p.count;

			  	p.total_rt -= v.endtime - v.starttime;
			  	p.avg_rt = p.count == 0 ? 0: p.total_rt / p.count;

				p.total_iosize -= v.iosize;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_rt) / (1024*1024); //MB/s

			}			
			return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_rt: 0, 
			  	avg_rt: 0,

				total_iosize: 0,			  	
				throughput: 0
		  	};
		}
	);

	Timeline_RT_Chart4
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension4)
		.group(groupNewStartTimeDimension4)
		.valueAccessor(function (d) {
				return d.value.avg_rt;
		})
		.centerBar(true)
		.gap(bargap)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second)
// 		.elasticX(true)
// 		.y(d3.scale.linear().domain([0, 100])) 
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			TimeLine_SysLevelAvgRT_Chart.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				TimeLine_SysLevelAvgRT_Chart.focus(chart.filter());
			});
		})
*/
		;


	Timeline_Throughput_Chart4
		.width(width1)
		.height(height1)
		.transitionDuration(transition_duration_delay)
		.margins({top: top1, right: right1, bottom: bottom1, left: left1})
		.dimension(NewStartTimeDimension4)
		.group(groupNewStartTimeDimension4)
		.valueAccessor(function (d) {
				return d.value.throughput;
		})
		.centerBar(true)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
// 		.xUnits(d3.time.second) */
// 		.elasticX(true) */
// 		.y(d3.scale.linear().domain([0, 100])) */
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.data.value.count + " #\n" +
				"start time: " + d.data.value.start_time + " s\n" +
 				"avg response time: " + d.data.value.avg_rt.toFixed(6) + " s\n" +
 				"total io size: " + (d.data.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.data.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})
/*
		.renderlet(function (chart) {
// 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 
			Timeline_Throughput_Chart1.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				Timeline_Throughput_Chart1.focus(chart.filter());
			});
		})
*/
		.gap(bargap)
		;		
		
	var ALLIODimension4 = ndx.dimension(function (d) {
		return d.all;
		});            

	var groupALLIODimension4 = ALLIODimension2.group().reduce(
		function (p, v) {
			if(v.entry_type == 1)
			{
				++p.count;
				
				if(p.start_time > v.starttime) p.start_time = v.starttime;
				
				
			  	p.total_start_end_interval += v.endtime - v.starttime
				p.total_iosize += v.iosize;
				
			  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}		  	
		  	return p;		  
		},
	  	function (p, v) {
	  		if(v.entry_type == 1)
	  		{
			  	--p.count;

			  	p.total_start_end_interval -= v.endtime - v.starttime;
				p.total_iosize -= v.iosize;
				
			  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
				p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			}						
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				variance:0,
				std_dev:0
		  	};
		}
	);

	NR_Dataset4ND
    .dimension(ALLIODimension4)
    .group(groupALLIODimension4)
    .valueAccessor(function (p) { 
    	return p.value.count; 
    })
    .formatNumber(d3.format("g"))
    ;

	    
    AvgThroughtputND4
    .dimension(ALLIODimension4)
    .group(groupALLIODimension4)
    .valueAccessor(function (p) { 
    	return p.value.throughput; 
    })
    .formatNumber(d3.format(".8g"))
    ;

	AvgRTtimeND4
	.dimension(ALLIODimension4)
	.group(groupALLIODimension4)
	.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalIOSizeND4
	.dimension(ALLIODimension4)
	.group(groupALLIODimension4)
	.valueAccessor(function (p) {
			return p.value.total_iosize;
	})
	.formatNumber(d3.format(".8g"))
	;

	TotalRTtimeND4
	.dimension(ALLIODimension4)
	.group(groupALLIODimension4)
	.valueAccessor(function (p) {
			return p.value.total_start_end_interval;
	})
	.formatNumber(d3.format(".8g"))
	;

	VarianceND4
	.dimension(ALLIODimension4)
	.group(groupALLIODimension4)
	.valueAccessor(function (p) {
			return p.value.variance;
	})
		    .on("preRender", function(chart){
     //        // 1. calculating the average with the data left after filtering.
     //        // 2. calculating the deviating with the average for each entry in the data set.
     //        // 3. squaring the result from (2) and sum all the entry in the data set.
     //        // 4. dividing the result from (3) with the number of the entries in the data set.
     //        // 5. from (4) I can obtain the variance.
     //        // 6. I want to make the result from (4) label or title of this chart.
	    // 	// console.log(chart.dimension().group().all().forEach(d));

	    	// sigma (pow((avg-e(x)),2)) / count
	    	// squere 
	    	// var Test = chart.dimension().group().top(Infinity);
	    	// Test.forEach(function(d1, a1, b1) {
	    	// 	console.log(d1.value.avg_start_end_interval);
	    	// })
	    	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
		.on("preRedraw", function(chart){
        	var Dim = chart.dimension().top(Infinity);

	    	// var avg = 0;
	    	// Dim.forEach(function(d1, a1, b1) {
	    	// 	avg += d1.endtime - d1.starttime;
	    	// });
	    	// avg = avg / Dim.length;

	    	var variance = 0;
	    	Dim.forEach(function(d1, a1, b1) {
	    		variance += Math.pow(d1.endtime - d1.starttime - chart.group().all()[0].value.avg_start_end_interval, 2);
	    	});
	    	variance = variance / Dim.length;

	    	var std_dev = Math.sqrt(variance);

	    	// chart.group().all()[0].value is different from chart.dimension().group().all()[0].value
	    	// the former returns what I want, the later returns 1... which is what I dont' want.
	    	chart.group().all()[0].value.variance = variance;
	    	chart.group().all()[0].value.std_dev = std_dev;	  
	    	// console.log(chart.group().all()[0].value);  	
	    })
	.formatNumber(d3.format(".8g"))
	;

	StdDeviationND4
	.dimension(ALLIODimension4)
	.group(groupALLIODimension4)
	.valueAccessor(function (p) {
			return p.value.std_dev;
	})
	.formatNumber(d3.format(".8g"))
	;

	var Process_Throughput_ChartDimension = ndx.dimension(function (d) {
		return d.processname;
		});            

	var groupProcess_Throughput_ChartDimension = Process_Throughput_ChartDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.total_start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.total_start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0
		  	};
		}
	);
	
	Process_Throughput_Chart
	    .width(Full_Width/4) // (optional) define chart width, :default = 200
	    .height(groupProcess_Throughput_ChartDimension.size() * 30 + 20 + 20) // (optional) define chart height, :default = 200
	    .dimension(Process_Throughput_ChartDimension) // set dimension
	    .group(groupProcess_Throughput_ChartDimension) // set group
	    .valueAccessor(function (p) {
			return p.value.throughput;
		})
	    // (optional) define margins
	    .margins({top: 0, left: 10, right: 10, bottom: 20})
	    // (optional) define color array for slices
/* 	    .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb']) */
	    // (optional) set gap between rows, default is 5
	    .gap(7)
	    // (optional) whether chart should render labels, :default = true
	    .renderLabel(true)
    	.label(function (p) {
			return p.key + ": "+ p.value.throughput.toFixed(3) + " MB/s";
		})
	    // (optional) by default pie chart will use group.key and group.value as its title
	    // you can overwrite it with a closure
		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.value.count + " #\n" +
				"start time: " + d.value.start_time + " s\n" +
 				"avg response time: " + d.value.avg_start_end_interval.toFixed(6) + " s\n" +
 				"total io size: " + (d.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.value.throughput.toFixed(3) + "MB/s\n" 
 				;
				return ab_text + text;
			})

	    // (optional) whether chart should render titles, :default = false
	    .renderTitle(true)
	    // (optional) specify the number of ticks for the X axis
	    .xAxis().ticks(n_rowchart_ticks);


    
	var ProcessNamePIDDimension = ndx.dimension(function (d) {
		return d.processname + "-" + d.pid;
		// return d.pid;
	});
	var groupProcessNamePIDDimension = ProcessNamePIDDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.total_start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.total_start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			
		  	if(p.StartTime > v.starttime) p.StartTime = v.starttime;
		  	if(p.EndTime < v.endtime) p.EndTime = v.endtime;

			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				StartTime: Number.MAX_VALUE,
				EndTime: 0
		  	};
		}
	);
	
	PID_Throughput_Chart
	    .width(Full_Width/4) // (optional) define chart width, :default = 200
	    .height(groupProcessNamePIDDimension.size() * 30 + 20 + 20) // (optional) define chart height, :default = 200
	    .dimension(ProcessNamePIDDimension) // set dimension
	    .group(groupProcessNamePIDDimension) // set group
	    .valueAccessor(function (p) {
			return p.value.throughput;
		})
	    // (optional) define margins
	    .margins({top: 0, left: 10, right: 10, bottom: 20})
	    // (optional) define color array for slices
/* 	    .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb']) */
	    // (optional) set gap between rows, default is 5
	    .gap(7)
	    // (optional) whether chart should render labels, :default = true
	    .renderLabel(true)
    	.label(function (p) {
			return p.key + ": "+ p.value.throughput.toFixed(6) + " MB/s";
		})
	    // (optional) by default pie chart will use group.key and group.value as its title
	    // you can overwrite it with a closure
	    		.title(function (d) {
				var ab_text = "";
				var text = 
				"io count: " + d.value.count + " #\n" +
				"start time: " + d.value.start_time + " s\n" +
 				"avg response time: " + d.value.avg_start_end_interval.toFixed(6) + " s\n" +
 				"total io size: " + (d.value.total_iosize / (1024*1024)).toFixed(3) + " MB\n" +
 				"throughput: " + d.value.throughput.toFixed(6) + "MB/s\n" 
 				;
				return ab_text + text;
			})

	    // (optional) whether chart should render titles, :default = false
	    .renderTitle(true)
	    // (optional) specify the number of ticks for the X axis
	    .xAxis().ticks(n_rowchart_ticks);

/*
  	var y_low = 0;
  	var y_high = groupProcessDimension[0].value.count;
  	var y_gap = Math.ceil(y_high * 0.1);
  	var y_low = 0 - y_gap;
  	var y_high = y_high + y_gap;
*/
    

	ProcessBubbleChart_x_low = IOTimeLineChart_x_low;
	
	var PID_BubbleChartDimension = ndx.dimension(function (d) {
		// return d.processname + "-" + d.pid;
		return d.pid;
	});
	var groupPID_BubbleChartDimension = PID_BubbleChartDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.total_start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.total_start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			
		  	if(p.StartTime > v.starttime) p.StartTime = v.starttime;
		  	if(p.EndTime < v.endtime) p.EndTime = v.endtime;

			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0,
				
				StartTime: Number.MAX_VALUE,
				EndTime: 0
		  	};
		}
	);

	PID_BubbleChart
		.width(width2)
		.height(height2)
    	.margins({top: 0, right: 60, bottom: 20, left: 60})
		.dimension(PID_BubbleChartDimension)
		.group(groupPID_BubbleChartDimension)
		.transitionDuration(transition_duration_delay)
		.colors(["green"])
/*
		.colorDomain([-12000, 12000])
		.colorAccessor(function (d) {
			return d.value.count;
		})
*/
		.keyAccessor(function (p) {
			return p.value.count;
		})
		.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
		})
		.radiusValueAccessor(function (p) {
/* 			return p.value.count / all.value()*10000; // 원의 지름이 I/O 요청 개수에 따라서 커짐, 프로세스간의 I/O 요청 개수들을 쉽게 비교하고 싶을 때 사용 */
			return 2;
		})
	/* 	.maxBubbleRelativeSize(30) */
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
		.y(d3.scale.linear().domain([-1, 1]))
		.r(d3.scale.linear().domain([0, 7000]))
		.elasticY(true)
 		.yAxisPadding(0.5) 
		.elasticX(true)
 		// .xAxisPadding(0.5) 
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderLabel(true)
		.renderTitle(true)
		.label(function (p) {
			return p.key;
		})
		.title(function (p) {
			return p.key 
			+ "\nI/O #" + p.value.count 
			+ "\n1st I/O at: " + p.value.StartTime
			+ "\nAvg. RT: " + p.value.avg_start_end_interval.toFixed(8)
			+ "\nStart time: " + p.value.StartTime.toFixed(8)
			+ "\nEnd Time: " + p.value.EndTime.toFixed(8);
		})
		.xAxis().tickFormat(function (v) {
			return "#" + v;
		})
		.ticks(n_bubblechart_ticks);
		// the both setting (x/yAxis) aren't working at the same time
		// .yAxis().tickFormat(function (v) {
		// 	return v + "s";
		// })
		;

 	var fluctuation = ndx.dimension(function (d) {
                return d.rttime.toFixed(4);
            });
    var fluctuationGroup = fluctuation.group();

	RT_Distribution_Chart
		.width(width2)
        .height(height2)
        .margins({top: 0, right: 60, bottom: 20, left: 60})
        .dimension(fluctuation)
        .group(fluctuationGroup)
        .elasticY(true)
		.yAxisPadding("10%") 
        // .elasticX(true)
        // .xAxisPadding("10%") 
        .centerBar(true)
        // .gap(100)
        // .round(dc.round.floor)
        .x(d3.scale.linear().domain([0, MaxIORT]))
        // .x(d3.scale.linear().domain([0, MaxIORT]))
        .renderHorizontalGridLines(true)
        // .filterPrinter(function (filters) {
        //     var filter = filters[0], s = "";
        //     s += numberFormat(filter[0]) + "% -> " + numberFormat(filter[1]) + "%";
        //     return s;
        // })
        .xAxis()
        .tickFormat(function (v) {
            return v + "s";
        });

	var ProcessNameDimension = ndx.dimension(function (d) {
		return d.processname;
		});            

	var groupProcessNameDimension = ProcessNameDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.total_start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.total_start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.total_start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.total_start_end_interval) / (1024*1024);
			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	total_start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0
		  	};
		}
	);
	ProcessName_IORatio_Chart
  		.width(width2/2) // (optional) define chart width, :default = 200
  		.height(height2) // (optional) define chart height, :default = 200
  		.transitionDuration(transition_duration_delay) // (optional) define chart transition duration, :default = 350
  		// (optional) define color array for slices .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb'])
  		// (optional) define color domain to match your data domain if you want to bind data or color.colorDomain([-1750, 1644])
  		// (optional) define color value accessor
/*
  		.colorAccessor(function(d, i){return d.data.value;})
  		.radius(90) // define pie radius
*/
		// (optional) if inner radius is used then a donut chart will
		// be generated instead of pie chart
		.innerRadius(20)
		.dimension(ProcessNameDimension) // set dimension
		.group(groupProcessNameDimension) // set group
		// (optional) by default pie chart will use group.key as it's label
		// but you can overwrite it with a closure
		.label(function(d) { return d.data.key + "(" + Math.floor(d.data.value.count / all.value() * 100) + "%)"; })
		// (optional) whether chart should render labels, :default = true
/* 		.renderLabel(true) */
		// (optional) by default pie chart will use group.key and group.value as its title
		// you can overwrite it with a closure
/*
		.title(function(d) { return d.data.key + ": "+ Math.floor(d.data.value / all.value() * 100) + "%\n"	
			+ "The number of I/O = " + d..value + "\n";
		})
*/
		.title(function(d) { return d.data.key + ": "+ Math.floor(d.data.value.count / all.value() * 100) + "%\n"	
			+ "The number of I/O = " + d.data.value.count + "\n";
		})		
    	.valueAccessor(function(d) {
	    	return d.value.count;
    	})
		// (optional) whether chart should render titles, :default = false
		.renderTitle(true);

  	var TypeDimension = ndx.dimension(function(d) {return d.rw});
  	var groupTypeDimension = TypeDimension.group();  	

	IOType_IORatio_Chart
	  	.width(width2/2) // (optional) define chart width, :default = 200
	  	.height(height2) // (optional) define chart height, :default = 200
	  	.transitionDuration(transition_duration_delay) // (optional) define chart transition duration, :default = 350
	  	// (optional) define color array for slices
	  	// (optional) define color domain to match your data domain if you want to bind data or color.colorDomain([-1750, 1644])
	  	// (optional) define color value accessor
/*
	  	.colorAccessor(function(d, i){return d.data.value;})
	  	.radius(90) // define pie radius
*/
	  	// (optional) if inner radius is used then a donut chart will
	  	// be generated instead of pie chart
	  	.innerRadius(20)
	  	.dimension(TypeDimension) // set dimension
	  	.group(groupTypeDimension) // set group)
	  	// (optional) by default pie chart will use group.key as it's label
	  	// but you can overwrite it with a closure
	  	.label(function(d) { return d.data.key + "(" + Math.floor(d.data.value / all.value() * 100) + "%)"; })
	  	// (optional) whether chart should render labels, :default = true
	  	.renderLabel(true)
	  	// (optional) by default pie chart will use group.key and group.value as its title
	  	// you can overwrite it with a closure
	  	.title(function(d) { return d.data.key + "\n"	
		  	+ ": " + d.data.value + "\n"; 
	  	})
	  	// (optional) whether chart should render titles, :default = false
	  	.renderTitle(true)
	  	;
                
	var FileCountDimension = ndx.dimension(function(d) {return d.filename});
	var groupFileCountDimension = FileCountDimension.group()
	/*
.reduce(
		function(p,v) {
			++p.count;
			return p;
		},
		funciton(p,v) {
			--p.count;
			return p;
		},
		function() {
			return {count: 0};
		}
	)
*/
	;
	
	File_AccessCount_Chart
		.width(Full_Width/4)
		.height(groupFileCountDimension.size() * 30 + 20 + 20)
		.margins({top: 0, left: 10, right: 10, bottom: 20})
		.dimension(FileCountDimension)
		.group(groupFileCountDimension)
		.colors(['#3182bd'])
		.label(function (d){
			return d.key + ": #" + d.value;
		})
		.xAxis().ticks(n_rowchart_ticks);                   
                                


/*
	// 데이터 원본에 대해서만 조작 가능
	// d.데이터 필드가 바로 나옴
	// d.throughput은 없음
	// d는 원본 데이터
	 // set dimension
 	StatTable
        .dimension(ALLIODimension)
        // data table does not use crossfilter group but rather a closure
        // as a grouping function
        .group(function(d) {
                return d.all;
            })
        // (optional) max number of records to be shown, :default = 25
        .size(1)
        // dynamic columns creation using an array of closures
        .columns([
            function(d) { return d.throughput.toFixed(3) + " MB/s"; },
            function(d) { return d.avg_start_end_interval.toFixed(7) + " seconds"; },
            function(d) { return (d.total_iosize/(1024*1024)).toFixed(3)+ " MB"; },
            function(d) { return d.total_start_end_interval.toFixed(6)+ " seconds" },
        ])
        // (optional) sort using the given field, :default = function(d){return d;}
        .sortBy(function(d){ return d.data.value.total_iosize; })
        // (optional) sort order, :default ascending
        .order(d3.ascending);
*/

	/*
*/
/*
	var FileRTDimension = ndx.dimension(function(d) {return d.filename});
	var groupFileRTDimension = FileRTDimension.group()
	;
		
	FileRTChart
		.width(Full_Width/2)
		.height(groupFileRTDimension.size() * 30 + 20 + 20)
		.margins({top: 0, left: 10, right: 10, bottom: 20})
		.dimension(FileRTDimension)
		.group(groupFileRTDimension)
		.colors(['#3182bd'])
		.label(function (d){
			return d.key + ": #" + d.value;
		})
		.xAxis().ticks(10);
*/      
    dc.dataCount(".dc-data-count")
    	.dimension(ndx)
    	.group(all);

                
	dc.renderAll();

});
</script>


</body></html>