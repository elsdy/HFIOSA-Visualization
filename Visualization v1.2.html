<!DOCTYPE html>
<html><head>
	<meta charset="UTF-8" >
	<link rel="StyleSheet" href="./Visualization.css" type="text/css" >
	<title> Hierarchical Performance Results Visualisation </title>
</head>
<body onload="window.resizeTo(1600, 1400)" >

<script type="text/javascript" src="../js/d3/d3.js" >


</script>
<script type="text/javascript" src="../js/crossfilter/crossfilter.js" >


</script>
<script type="text/javascript" src="../js/dc/dc.js" >


</script>
<script type="text/javascript" >
</script>

<!-- label, # of recored to be analyzed -->
<div class="graph_label" id="title" >
	<h1 style="" >
		계층적 성능 분석 결과 
	</h1>
	<div class="dc-data-count" style="float:left; " >
<!--
		<input type="file" id="thefile" onchange="alertFilename()" />		
		<br>
		<br>
-->
		선택된 데이터 <span class="filter-count" > </span> 개 / 전체 데이터 <span class="total-count" > </span> 개 <a href="javascript:dc.filterAll(); dc.renderAll();" > 전체 필터 및 그룹핑 초기화 </a> 
	</div>
	<br>
</div>

<div class="row" style="clear:both; " >
	<div id="io-timeline-chart" class="dc-chart" >
		<h2>
			<strong> 시간별 요청 I/O 특징 (특정 부분 선택 가능)  </strong> 
		</h2>
		(x축: 시간축, y축: 평균 응답시간(위그래프)) <a class="reset" href="javascript:IOVolumeChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
</div>
<div class="row" >
	<div id="io-volume-chart" >
		<h2>
			<strong> 시간구간별 처리량  </strong> 
		</h2>
		(x축: 시간축, y축: 처리량(아래그래프)) <a class="reset" href="javascript:IOVolumeChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a>
	</div>
</div>

<div class="row" style="clear:both; " >
	<div id="process_bubble_chart" class="dc-chart" >
		<h2>
			<strong> PID별 I/O 특성</strong> 
		</h2>
		(x축: I/O 요청 개수, y축: I/O별 평균 응답 시간) <a class="reset" href="javascript:ProcessBubbleChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
	<div id="process_chart" class="dc-chart" >
		<h2>
			<strong> 프로세스 이름별 I/O 요청 비율 </strong> 
		</h2>
		(면적: I/O 요청 비율) <a class="reset" href="javascript:ProcessNameChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
	<div id="type_chart" class="dc-chart" >
		<h2>
			<strong> 읽기 / 쓰기 비율 </strong> 
		</h2>
		(면적: I/O 요청 비율) <a class="reset" href="javascript:TypeChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
</div>

<div class="row">
	<div id="process_throughput_chart">
		<h2>
			<strong> 프로세스별 평균 처리량 </strong>
		</h2>
	</div>
	<div id="pid_throughput_chart">
		<h2>
			<strong> PID별 평균 처리량 </strong>
		</h2>
	</div>
</div>

<div class="row" >
	<div id="io_category_aver_block_emmc_response_time_chart" class="dc-chart" >
		<h2>
			<strong> I/O별 블록, eMMC 레벨 평균 응답 시간</strong> 
		</h2>
		(x축: I/O별 평균 응답 시간, y축: (아래부터) eMMC, 블록 레벨) <a class="reset" href="javascript:IOCategoryAverBlockeMMCRTChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
	<div id="io_category_chart" class="dc-chart" >
		<h2>
			<strong> I/O 종류별 요청 개수</strong> 
		</h2>
		(x축: I/O 요청 개수, y축: I/O 종류) <a class="reset" href="javascript:IOCategoryChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
</div>
<div class="row" >
	<div id="io_category_aver_response_time_chart" class="dc-chart" >
		<h2>
			<strong> I/O 종류별 평균 응답 시간</strong> 
		</h2>
		(x축: 평균 응답 시간, y: I/O 종류) <a class="reset" href="javascript:IOCategoryAverRTChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
	<div id="file_count_chart" class="dc-chart" >
		<h2>
			<strong> 접근 파일별 I/O 요청 개수</strong> 
		</h2>
		(x축: I/O 요청 개수, y축: 접근 파일) <a class="reset" href="javascript:FileAccessCountChart.filterAll();dc.redrawAll();" style="display:none; " > 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix" >
		</div>
	</div>
</div>


	
<!--
	<div id="file_rt_chart">
		<h2>
			<strong> 접근 파일별 평균 응답 시간</strong> 
		</h2>
		(x축: 평균 응답 시간, y축: 접근 파일) <a class="reset" href="javascript:FileRTChart.filterAll();dc.redrawAll();" style="display: none;"> 해당 필터 및 그룹핑 초기화  </a> 
		<div class="clearfix">
		</div>
	</div>
-->
<!--
</div>
<div id="io_category_aver_4layer_response_time_chart" style="clear:left">
	<h2>
		<strong> Average eMMC, Block, Cache, FS Layer Response Time per each IO category</strong> ㄴㅊ
	</h2>
	(x: Aver. Response Time, y: categories (eMMC-blue, BLOCK-red, CACHE-green, FS-blue )) <a class="reset" href="javascript:IOCategoryAver4LayerRTChart.filterAll();dc.redrawAll();" style="display: none;"> 해당 필터 및 그룹핑 초기화  </a> 
</div>
-->

<script>

var ProcessBubbleChart = dc.bubbleChart("#process_bubble_chart");

var ProcessNameChart = dc.pieChart("#process_chart");
var TypeChart = dc.pieChart("#type_chart");

var IOCategoryChart = dc.rowChart("#io_category_chart");
var IOCategoryAverRTChart = dc.barChart("#io_category_aver_response_time_chart");
var IOCategoryAverBlockeMMCRTChart = dc.barChart("#io_category_aver_block_emmc_response_time_chart");

/* var IOCategoryAver4LayerRTChart = dc.barChart("#io_category_aver_4layer_response_time_chart"); */

var FileAccessCountChart = dc.rowChart("#file_count_chart");

/* var FileRTChart = dc.barChart("#file_rt_chart"); */

var IOTimeLineChart = dc.compositeChart("#io-timeline-chart");
var IOVolumeChart = dc.barChart("#io-volume-chart");

var ProcessThroughputChart = dc.rowChart("#process_throughput_chart");
var PIDThroughputChart = dc.rowChart("#pid_throughput_chart");


var Full_Width = 1600;
var Default_Height = 180;

d3.csv("../final_result.csv", function(error, data) {


	var IOTimeLineChart_x_low = Number.MAX_VALUE;
	var IOTimeLineChart_x_high = 0;
	
	var ProcessBubbleChart_x_low = Number.MAX_VALUE;
	var ProcessBubbleChart_x_high = 0;
	
	var transition_duration_delay = 2500;
	
	var n_timeline_unit = 400; // 타임 라인 그래프의 구간을 몇으로 할 것인지 결정
	var time_slice = 0.00001;
/* 	var entry_count = 0; */
	
	// Parse numbers, and sort by value.
	data.forEach(function(d) {
	  	// d.processname
	  	d.pid = +d.pid;
	  	d.sys = +d.sys;
	  	d.vfs = +d.vfs;
	  	d.fs = +d.fs;
	  	d.cache = +d.cache;
	  	d.block = +d.block;
	  	d.driver = +d.driver;
	  	d.storage = +d.storage;
	  	d.journaling = +d.journaling;
	  	d.total = +d.total
	  	d.wait = +d.wait;
	  	
	  	d.iosize = +d.iosize;
	  	// d.type
	  	// d.filename
	  	d.starttime = +d.starttime;
	  	d.endtime = +d.endtime;

	  	d.linenumber = +d.linenumber;
	  	
	  	// d.category
	  	if(IOTimeLineChart_x_high < d.starttime) IOTimeLineChart_x_high = d.starttime;
	  	if(IOTimeLineChart_x_low > d.starttime) IOTimeLineChart_x_low = d.starttime;
	  	
  	});
  	
	var div_timeunit = +((IOTimeLineChart_x_high - IOTimeLineChart_x_low)/n_timeline_unit).toFixed(6);
	 
/*
  		// Parse numbers, and sort by value.
	data.forEach(function(d) {
		d.timeline_group = Math.floor(d.starttime/ div_timeunit);	// 소숫점 이하를 없앤다. 
  	});
*/

	// Parse numbers, and sort by value.
	data.forEach(function(d) {
/*
		d.offset = d.starttime - IOTimeLineChart_x_low;
		d.offset2 = d.offset / div_timeunit;
		d.offset3 = Math.floor(d.offset2);
		d.offset4 = d.offset3 * div_timeunit;
*/
		d.timeline_group = IOTimeLineChart_x_low + Math.floor((d.starttime - IOTimeLineChart_x_low)/ div_timeunit) * div_timeunit;	// 소숫점 이하를 없앤다. 
  	});
  
  	IOTimeLineChart_x_low = Math.floor(IOTimeLineChart_x_low)-3;
  	IOTimeLineChart_x_high = Math.ceil(IOTimeLineChart_x_high)+3;
  	
  	ProcessBubbleChart_x_low = IOTimeLineChart_x_low;
  
  	// feed it through crossfilter
  	var ndx = crossfilter(data);

  	// define group all for counting
  	var all = ndx.groupAll();


	var StartTimeDimension = ndx.dimension(function (d) {
		return d.timeline_group;
	});
	var groupStartTimeDimension = StartTimeDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.start_end_interval / p.count;
			p.throughput = (p.total_iosize /  p.start_end_interval) / (1024 *1024)  ;
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.start_end_interval) / (1024 *1024);
			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0
		  	};
		}
	);
  
/*
	var groupVolumeStartTimeDimension = StartTimeDimension.group()
		.reduce(
			function (p, v) {
				++p.count;


			},
			function (p, v) {
				--p.count;

				p.total_responsetime -= v.endtime - v.start;
			},
			function() {
				return {
					count: 0,
				};
			}			
		)
	;
*/

	IOTimeLineChart
		.width(Full_Width)
		.height(Default_Height)
		.transitionDuration(transition_duration_delay)
		.margins({top: 10, right: 50, bottom: 20, left: 70})
		.dimension(StartTimeDimension)
		.group(groupStartTimeDimension)
		.valueAccessor(function (d) {
			return d.value.avg_start_end_interval;
		})
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
/* 		.xUnits(d3.time.second) */
/* 		.elasticX(true) */
		.y(d3.scale.linear().domain([0, 0.0004]))
		.elasticY(true)
/* 		.yAxisPadding(100) */
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.brushOn(false)
		.compose([
			dc.lineChart(IOTimeLineChart)
			.group(groupStartTimeDimension)
			.valueAccessor(function (d) {
				return d.value.avg_start_end_interval;
			})
			.renderArea(true)
			.title(function (d) {
				var ab_text = "";
				var text = "start time: " + d.value.start_time + "\n" +
 				"finish_start_interval: " + d.value.avg_start_end_interval.toFixed(6) + "\n"
					  ;

				return ab_text + text;
			})
		])
		.xAxis()
		;

	IOVolumeChart.width(Full_Width)
		.height(Default_Height)
		.transitionDuration(transition_duration_delay)
		.margins({top: 10, right: 50, bottom: 20, left: 70})
		.dimension(StartTimeDimension)
		.group(groupStartTimeDimension)
		.valueAccessor(function (d) {
				return d.value.throughput;
		})
		.centerBar(true)
		.gap(0)
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
/* 		.xUnits(d3.time.second) */
		.elasticX(true)
		.y(d3.scale.linear().domain([0, 100]))
		.elasticY(true)
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderlet(function (chart) {
/* 			chart.select("g.y").style("display", "none"); // y축 라벨 사라지게 하는 것 */
			IOTimeLineChart.filter(chart.filter());
		})
		.on("filtered", function (chart) {
			dc.events.trigger(function () {
				IOTimeLineChart.focus(chart.filter());
			});
		});

  
  	
	var ProcessThroughputDimension = ndx.dimension(function (d) {
		return d.processname;
		});            

	var groupProcessThroughputDimension = ProcessThroughputDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.start_end_interval) / (1024 *1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.start_end_interval) / (1024 *1024);
			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0
		  	};
		}
	);
	
	ProcessThroughputChart
	    .width(Full_Width/2) // (optional) define chart width, :default = 200
	    .height(groupProcessThroughputDimension.size() * 30 + 20 + 20) // (optional) define chart height, :default = 200
		.margins({top: 10, right: 50, bottom: 20, left: 70})
	    .dimension(ProcessThroughputDimension) // set dimension
	    .group(groupProcessThroughputDimension) // set group
	    .valueAccessor(function (p) {
			return p.value.throughput;
		})
	    // (optional) define margins
	    .margins({top: 20, left: 10, right: 10, bottom: 20})
	    // (optional) define color array for slices
/* 	    .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb']) */
	    // (optional) set gap between rows, default is 5
	    .gap(7)
	    // (optional) whether chart should render labels, :default = true
	    .renderLabel(true)
    	.label(function (p) {
			return p.key + ": "+ p.value.throughput.toFixed(3) + " MB/s";
		})
	    // (optional) by default pie chart will use group.key and group.value as its title
	    // you can overwrite it with a closure
	    .title(function(d) { return d.value.throughput.toFixed(3) + " MB/s"; })
	    // (optional) whether chart should render titles, :default = false
	    .renderTitle(true)
	    // (optional) specify the number of ticks for the X axis
	    .xAxis().ticks(4);


    
	var PIDThroughputDimension = ndx.dimension(function (d) {
		return d.processname + "-" + d.pid;
	});
	var groupPIDThroughputDimension = PIDThroughputDimension.group().reduce(
		function (p, v) {
			++p.count;
			
			if(p.start_time > v.starttime) p.start_time = v.starttime;
			
		  	p.start_end_interval += v.endtime - v.starttime
			p.total_iosize += v.iosize;
			
		  	p.avg_start_end_interval = p.start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.start_end_interval) / (1024 *1024);
		  	
		  	return p;		  
		},
	  	function (p, v) {
		  	--p.count;

		  	p.start_end_interval -= v.endtime - v.starttime;
			p.total_iosize -= v.iosize;
			
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.start_end_interval / p.count;
			p.throughput = p.count == 0 ? 0: (p.total_iosize /  p.start_end_interval) / (1024 *1024);
			
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
			  	start_time: Number.MAX_VALUE,
			  	
			  	start_end_interval: 0, 
				total_iosize: 0,

			  	avg_start_end_interval: 0,
				throughput: 0
		  	};
		}
	);
	
	PIDThroughputChart
	    .width(Full_Width/2) // (optional) define chart width, :default = 200
	    .height(groupPIDThroughputDimension.size() * 30 + 20 + 20) // (optional) define chart height, :default = 200
		.margins({top: 10, right: 50, bottom: 20, left: 70})
	    .dimension(PIDThroughputDimension) // set dimension
	    .group(groupPIDThroughputDimension) // set group
	    .valueAccessor(function (p) {
			return p.value.throughput;
		})
	    // (optional) define margins
	    .margins({top: 20, left: 10, right: 10, bottom: 20})
	    // (optional) define color array for slices
/* 	    .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb']) */
	    // (optional) set gap between rows, default is 5
	    .gap(7)
	    // (optional) whether chart should render labels, :default = true
	    .renderLabel(true)
    	.label(function (p) {
			return p.key + ": "+ p.value.throughput.toFixed(3) + " MB/s";
		})
	    // (optional) by default pie chart will use group.key and group.value as its title
	    // you can overwrite it with a closure
	    .title(function(d) { return d.value.throughput.toFixed(3) + " MB/s"; })
	    // (optional) whether chart should render titles, :default = false
	    .renderTitle(true)
	    // (optional) specify the number of ticks for the X axis
	    .xAxis().ticks(4);

/*
  	var y_low = 0;
  	var y_high = groupProcessDimension[0].value.count;
  	var y_gap = Math.ceil(y_high * 0.1);
  	var y_low = 0 - y_gap;
  	var y_high = y_high + y_gap;
*/
    
  	var ProcessDimension = ndx.dimension(function(d){ return d.pid });
  	var groupProcessDimension = ProcessDimension.group().reduce(
		//add
		function (p, v) {
			++p.count;
			p.start_end_interval += v.endtime - v.starttime;
			p.avg_start_end_interval = p.start_end_interval/p.count;	
			
		  	p.processname = v.processname;
		  	p.pid = +v.pid;	
		  	
		  	if(p.StartTime > v.starttime) p.StartTime = v.starttime;
		  	if(p.EndTime < v.endtime) p.EndTime = v.endtime;
		  	
		  	return p;
		},
		//remove
		function (p, v) {
			--p.count;
			p.start_end_interval -= v.endtime - v.starttime;
		  	p.avg_start_end_interval = p.count == 0 ? 0: p.start_end_interval / p.count;
		  	
		  	
		  	return p;
		},
		//init
		function () {
			return {
				count: 0, 
				start_end_interval: 0, avg_start_end_interval: 0, pid: 0, StartTime: Number.MAX_VALUE,
				EndTime: 0
			};		
		}
  	)
/*
  	.order(function (p) { return p.count;})
  	.top(Infinity)
*/
  	;

	ProcessBubbleChart
		.width(Full_Width*2/3)
		.height(250)
    	.margins({top: 20, right: 60, bottom: 20, left: 60})
		.dimension(ProcessDimension)
		.group(groupProcessDimension)
		.transitionDuration(transition_duration_delay)
		.colors(["red"])
/*
		.colorDomain([-12000, 12000])
		.colorAccessor(function (d) {
			return d.value.count;
		})
*/
		.keyAccessor(function (p) {
			return p.value.count;
		})
		.valueAccessor(function (p) {
			return p.value.avg_start_end_interval;
		})
		.radiusValueAccessor(function (p) {
/* 			return p.value.count / all.value()*10000; // 원의 지름이 I/O 요청 개수에 따라서 커짐, 프로세스간의 I/O 요청 개수들을 쉽게 비교하고 싶을 때 사용 */
			return 2;
		})
	/* 	.maxBubbleRelativeSize(30) */
		.x(d3.scale.linear().domain([IOTimeLineChart_x_low, IOTimeLineChart_x_high]))
		.y(d3.scale.linear().domain([-1, 1]))
		.r(d3.scale.linear().domain([0, 7000]))
		.elasticY(true)
		.yAxisPadding(0.5)
		.elasticX(false)
/* 		.xAxisPadding(2000) */
		.renderHorizontalGridLines(true)
		.renderVerticalGridLines(true)
		.renderLabel(true)
		.renderTitle(true)
		.label(function (p) {
			return p.value.processname + "-" + p.key;
		})
		.title(function (p) {
			return p.value.processname + "-" + p.key
			+ "\nI/O #" + p.value.count 
			+ "\n1st I/O at: " + p.value.StartTime
			+ "\nAvg. RT: " + p.value.avg_start_end_interval.toFixed(8)
			+ "\nStart time: " + p.value.StartTime.toFixed(8)
			+ "\nEnd Time: " + p.value.EndTime.toFixed(8);
		})
		.yAxis().tickFormat(function (v) {
			return v + "s";
		})
		;

	var ProcessnameDimension = ndx.dimension(function(d) { return d.processname });
	var groupProcessnameDimension = ProcessnameDimension.group();
              
	ProcessNameChart
  		.width(Full_Width*1/6) // (optional) define chart width, :default = 200
  		.height(250) // (optional) define chart height, :default = 200
  		.transitionDuration(transition_duration_delay) // (optional) define chart transition duration, :default = 350
  		// (optional) define color array for slices .colors(['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#dadaeb'])
  		// (optional) define color domain to match your data domain if you want to bind data or color.colorDomain([-1750, 1644])
  		// (optional) define color value accessor
/*
  		.colorAccessor(function(d, i){return d.data.value;})
  		.radius(90) // define pie radius
*/
		// (optional) if inner radius is used then a donut chart will
		// be generated instead of pie chart
		.innerRadius(20)
		.dimension(ProcessnameDimension) // set dimension
		.group(groupProcessnameDimension) // set group
		// (optional) by default pie chart will use group.key as it's label
		// but you can overwrite it with a closure
		.label(function(d) { return d.data.key + "(" + Math.floor(d.data.value / all.value() * 100) + "%)"; })
		// (optional) whether chart should render labels, :default = true
/* 		.renderLabel(true) */
		// (optional) by default pie chart will use group.key and group.value as its title
		// you can overwrite it with a closure
		.title(function(d) { return d.data.key + ": "+ Math.floor(d.data.value / all.value() * 100) + "%\n"	
			+ "The number of I/O = " + d.data.value + "\n";
		})
		// (optional) whether chart should render titles, :default = false
		.renderTitle(true);

  	var TypeDimension = ndx.dimension(function(d) {return d.type});
  	var groupTypeDimension = TypeDimension.group();  	

	TypeChart
	  	.width(250) // (optional) define chart width, :default = 200
	  	.height(250) // (optional) define chart height, :default = 200
	  	.transitionDuration(transition_duration_delay) // (optional) define chart transition duration, :default = 350
	  	// (optional) define color array for slices
	  	// (optional) define color domain to match your data domain if you want to bind data or color.colorDomain([-1750, 1644])
	  	// (optional) define color value accessor
/*
	  	.colorAccessor(function(d, i){return d.data.value;})
	  	.radius(90) // define pie radius
*/
	  	// (optional) if inner radius is used then a donut chart will
	  	// be generated instead of pie chart
	  	.innerRadius(20)
	  	.dimension(TypeDimension) // set dimension
	  	.group(groupTypeDimension) // set group)
	  	// (optional) by default pie chart will use group.key as it's label
	  	// but you can overwrite it with a closure
	  	.label(function(d) { return d.data.key + "(" + Math.floor(d.data.value / all.value() * 100) + "%)"; })
	  	// (optional) whether chart should render labels, :default = true
	  	.renderLabel(true)
	  	// (optional) by default pie chart will use group.key and group.value as its title
	  	// you can overwrite it with a closure
	  	.title(function(d) { return d.data.key + "\n"	
		  	+ ": " + d.data.value + "\n"; 
	  	})
	  	// (optional) whether chart should render titles, :default = false
	  	.renderTitle(true)
	  	;
	
  	var IOCategoryDimension = ndx.dimension(function(d) {return d.class});
  	var groupIOCategoryDimension = IOCategoryDimension.group();

	var IOCategoryChart_height = groupIOCategoryDimension.size() * 30 + 20 + 20;
	
	IOCategoryChart
		.width(Full_Width/3-50)
		.height(IOCategoryChart_height)
		.margins({top: 20, right: 10, bottom: 20, left: 10 })
		.dimension(IOCategoryDimension)
		.group(groupIOCategoryDimension)
/* 		.colors(['#3182bd']) */
		.label(function (d){
			return d.key + ": #" + d.value;
		})
		.xAxis().ticks(10);             
    
		
    var IOCategoryAverBlockeMMCRTDimension = ndx.dimension(function(d) {return d.class});
  	var groupIOCategoryAverBlockeMMCRTimension = IOCategoryAverBlockeMMCRTDimension.group().reduce(
	  	//add
	  	function (p, v) {
		  	++p.count;
		  	p.total_fs += v.fs; 
		  	p.total_cache += v.cache;
		  	p.total_block += v.block; 
		  	p.total_storage += v.storage;

		  	p.avg_fs = p.total_fs / p.count;
		  	p.avg_cache = p.total_cache / p.count;
		  	p.avg_block = p.total_block / p.count; 
		  	p.avg_storage = p.total_storage / p.count; 
		  	
		  	return p;	  	
	  	},
	  	//remove
	  	function (p, v) {
		  	--p.count;
		  	p.total_fs -= v.fs; 
		  	p.total_cache -= v.cache;
		  	p.total_block -= v.block; 
		  	p.total_storage -= v.storage;

		  	p.avg_fs = p.count == 0 ? 0 : p.total_fs / p.count;
		  	p.avg_cache = p.count == 0 ? 0 : p.total_cache / p.count;
		  	p.avg_block = p.count == 0 ? 0 : p.total_block / p.count;
		  	p.avg_storage = p.count == 0 ? 0 : p.total_storage / p.count;
		  	
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	total_block: 0,  total_storage: 0, total_fs: 0, total_cache: 0,
			  	avg_block: 0,  avg_storage: 0, avg_fs: 0, avg_cache: 0
		  	};
		}
	);	
	        
    IOCategoryAverBlockeMMCRTChart
    	.width(Full_Width*2/3)
    	.height(IOCategoryChart_height)
    	.margins({top: 20, right: 10, bottom: 20, left: 60})
    	.dimension(IOCategoryAverBlockeMMCRTDimension)
    	.group(groupIOCategoryAverBlockeMMCRTimension)
    	.valueAccessor(function(d) {
	    	return d.value.avg_storage;
    	})
    	.stack(groupIOCategoryAverBlockeMMCRTimension, function(d){return d.value.avg_block;})

    	.x(d3.scale.ordinal().domain(["", "R_4", "R_8", "R_16", "R_32", "R_128", "R_256", "R_512", "R_1024", "R_4096", "R_40960", 
    	"W_4", "W_8", "W_16", "W_32", "W_128", "W_256", "W_512", "W_1024", "W_4096", "W_40960"])) // manually written in the current version with Dc 1.3, DC 1.4 will cover this automatically
    	.xUnits(dc.units.ordinal)
		.renderHorizontalGridLines(true)
    	.centerBar(true)
    	.elasticY(true)
    	.brushOn(false)
    	.title(function(d){
	    	return d.key
	    				+ "\naver. fs response time: \n" + d.value.avg_fs.toFixed(8) 
	    				+ "\n total fs: " + d.value.total_fs.toFixed(8) + " count: " + d.value.count
	    				+ "\naver. cache response time: \n" + d.value.avg_cache.toFixed(8) 
	    				+ "\n total cache: " + d.value.total_cache.toFixed(8) + " count: " + d.value.count
					    + "\naver. block response time: \n" + d.value.avg_block.toFixed(8)
	    				+ "\n total block: " + d.value.total_block.toFixed(8) + " count: " + d.value.count
	    				+ "\naver. storage response time: \n" + d.value.avg_storage.toFixed(8)
	    				+ "\n total storage: " + d.value.total_storage.toFixed(8) + " count: " + d.value.count
;
    	})
    	.xAxis().ticks(20)
		;

	        
/*
    IOCategoryAver4LayerRTChart
    	.width(Full_Width*2/3)
    	.height(IOCategoryChart_height)
    	.margins({top: 20, right: 10, bottom: 20, left: 60})
    	.dimension(IOCategoryAverBlockeMMCRTDimension)
    	.group(groupIOCategoryAverBlockeMMCRTimension)
    	.valueAccessor(function(d) {
	    	return d.value.avg_storage;
    	})
    	.stack(groupIOCategoryAverBlockeMMCRTimension, function(d){return d.value.avg_block;})
    	.stack(groupIOCategoryAverBlockeMMCRTimension, function(d){return d.value.avg_cache;})
    	.stack(groupIOCategoryAverBlockeMMCRTimension, function(d){return d.value.avg_fs;})

    	.x(d3.scale.ordinal().domain(["", "R_4", "R_8", "R_16", "R_32", "R_128", "R_256", "R_512", "R_1024", "R_4096", "R_40960", 
    	"W_4", "W_8", "W_16", "W_32", "W_128", "W_256", "W_512", "W_1024", "W_4096", "W_40960"])) // manually written in the current version with Dc 1.3, DC 1.4 will cover this automatically
    	.xUnits(dc.units.ordinal)
		.renderHorizontalGridLines(true)
    	.centerBar(true)
    	.elasticY(true)
    	.brushOn(false)
    	.title(function(d){
	    	return d.key
	    				+ "\naver. fs response time: \n" + d.value.avg_fs.toFixed(8) 
	    				+ "\n total fs: " + d.value.total_fs.toFixed(8) + " count: " + d.value.count
	    				+ "\naver. cache response time: \n" + d.value.avg_cache.toFixed(8) 
	    				+ "\n total cache: " + d.value.total_cache.toFixed(8) + " count: " + d.value.count
					    + "\naver. block response time: \n" + d.value.avg_block.toFixed(8)
	    				+ "\n total block: " + d.value.total_block.toFixed(8) + " count: " + d.value.count
	    				+ "\naver. storage response time: \n" + d.value.avg_storage.toFixed(8)
	    				+ "\n total storage: " + d.value.total_storage.toFixed(8) + " count: " + d.value.counterIncrement
	    				;
    	})
    	.xAxis().ticks(20)
		;
*/

    var IOCategoryAverRTDimension = ndx.dimension(function(d) {return d.class});
  	var groupIOCategoryAverRTDimension = IOCategoryAverRTDimension.group().reduce(
	  	//add
	  	function (p, v) {
		  	++p.count;
/*
		  	p.total_sys += v.sys;
		  	p.total_vfs += v.vfs; 
		  	p.total_fs += v.fs; 
		  	p.total_cache += v.cache;
		  	p.total_block += v.block; 
		  	p.total_driver += v.driver; 
		  	p.total_storage += v.storage;
		  	p.total_journaling += v.journaling; 
		  	p.total_wait += v.wait;
		  	
		  	p.avg_sys = p.total_sys / p.count; 
		  	p.avg_vfs = p.total_vfs / p.count; 
		  	p.avg_fs = p.total_fs / p.count; 
		  	p.avg_cache = p.total_cache / p.count;
		  	p.avg_block = p.total_block / p.count; 
		  	p.avg_driver = p.total_driver / p.count; 
		  	p.avg_storage = p.total_storage / p.count; 
		  	p.avg_journaling = p.total_journaling / p.count;
		  	p.avg_wait = p.total_wait / p.count;			
*/
		  	p.start_end_interval += v.endtime - v.starttime;
		  	p.avg_start_end_interval = p.start_end_interval/p.count;
		  	
		  	return p;	  	
	  	},
	  	//remove
	  	function (p, v) {
		  	--p.count;
/*
		  	p.total_sys -= v.sys; 
		  	p.total_vfs -= v.vfs; 
		  	p.total_fs -= v.fs; 
		  	p.total_cache -= v.cache;
		  	p.total_block -= v.block; 
		  	p.total_driver -= v.driver; 
		  	p.total_storage -= v.storage;
		  	p.total_journaling -= v.journaling; 
		  	p.total_wait -= v.wait;
		  	
		  	p.avg_sys = p.count == 0 ? 0 : p.total_sys / p.count;
		  	p.avg_vfs = p.count == 0 ? 0 : p.total_vfs / p.count;
		  	p.avg_fs = p.count == 0 ? 0 : p.total_fs / p.count;
		  	p.avg_cache = p.count == 0 ? 0 : p.total_cache / p.count;
		  	p.avg_block = p.count == 0 ? 0 : p.total_block / p.count;
		  	p.avg_driver = p.count == 0 ? 0 : p.total_driver / p.count;
		  	p.avg_storage = p.count == 0 ? 0 : p.total_storage / p.count;
		  	p.avg_journaling = p.count == 0 ? 0 : p.total_journaling / p.count;
		  	p.avg_wait = p.count == 0 ? 0 : p.total_wait / p.count;	
*/
			p.start_end_interval -= v.endtime - v.starttime;
			p.avg_start_end_interval = p.count == 0 ? 0 : p.start_end_interval/p.count;
		  	
		  	return p;	  	
	  	},
	  	// init
	  	function() { 
		  	return {
			  	count: 0,
			  	
/*
			  	total_sys: 0,  total_vfs: 0,  total_fs: 0,  total_cache: 0, 
			  	total_block: 0,  total_driver: 0,  total_storage: 0, 
			  	total_journaling: 0,  total_wait: 0,
			  	
			  	avg_sys: 0,  avg_vfs: 0,  avg_fs: 0,  avg_cache: 0, 
			  	avg_block: 0,  avg_driver: 0,  avg_storage: 0, 
			  	avg_journaling: 0,  avg_wait: 0,
*/
			  	
		  		start_end_interval: 0, avg_start_end_interval: 0

		  	};
		}
	);	
	        
    IOCategoryAverRTChart
    	.width(Full_Width*2/3)
    	.height(IOCategoryChart_height/2)
    	.margins({top: 20, right: 10, bottom: 20, left: 60})
    	.dimension(IOCategoryAverRTDimension)
    	.group(groupIOCategoryAverRTDimension)
    	.valueAccessor(function(d) {
/* 	    	return d.value.avg_storage; */

	    	return d.value.avg_start_end_interval;
    	})
/*
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_driver;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_block;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_cache;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_journaling;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_fs;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_vfs;})
    	.stack(groupIOCategoryAverRTDimension, function(d){return d.value.avg_sys;})
*/
    	.x(d3.scale.ordinal().domain(["", "R_4", "R_8", "R_16", "R_32", "R_128", "R_256", "R_512", "R_1024", "R_4096", "R_40960", 
    	"W_4", "W_8", "W_16", "W_32", "W_128", "W_256", "W_512", "W_1024", "W_4096", "W_40960"])) // manually written in the current version with Dc 1.3, DC 1.4 will cover this automatically
/* 		.x(d3.scale.ordinal().domain([""] + groupIOCategoryAverRTDimension.all()) */
    	.xUnits(dc.units.ordinal)
    	.renderHorizontalGridLines(true)
    	.centerBar(true)
    	.elasticY(true)
    	.brushOn(false)
    	.title(function(d){
	    	return d.key + "\naver. IO response time: " + d.value.avg_start_end_interval.toFixed(8);
    	})
    	.xAxis().ticks(20)
		;

                
	var FileCountDimension = ndx.dimension(function(d) {return d.filename});
	var groupFileCountDimension = FileCountDimension.group()
	/*
.reduce(
		function(p,v) {
			++p.count;
			return p;
		},
		funciton(p,v) {
			--p.count;
			return p;
		},
		function() {
			return {count: 0};
		}
	)
*/
	;
	
	FileAccessCountChart
		.width(Full_Width/3-50)
		.height(groupFileCountDimension.size() * 30 + 20 + 20)
		.margins({top: 20, left: 10, right: 10, bottom: 20})
		.dimension(FileCountDimension)
		.group(groupFileCountDimension)
		.colors(['#3182bd'])
		.label(function (d){
			return d.key + ": #" + d.value;
		})
		.xAxis().ticks(10);
	
/*
	var FileRTDimension = ndx.dimension(function(d) {return d.filename});
	var groupFileRTDimension = FileRTDimension.group()
	;
		
	FileRTChart
		.width(Full_Width/2)
		.height(groupFileRTDimension.size() * 30 + 20 + 20)
		.margins({top: 20, left: 10, right: 10, bottom: 20})
		.dimension(FileRTDimension)
		.group(groupFileRTDimension)
		.colors(['#3182bd'])
		.label(function (d){
			return d.key + ": #" + d.value;
		})
		.xAxis().ticks(10);
*/
	
                   
                                
    dc.dataCount(".dc-data-count")
    	.dimension(ndx)
    	.group(all);

                
	dc.renderAll();
});
</script>


</body></html>